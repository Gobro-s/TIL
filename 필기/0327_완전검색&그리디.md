## 재귀
#### 반복 vs 재귀
-  반복 : 수행하는 작업이 완료될 때까지 계속 반복
	-  루프 (for, while 구조)
	
 - 재귀 : 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
	 - 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합한다.
	-  재귀 함수로 구현

#### 반복 구조
- 초기화 : 반복되는 명령문을 실행하기 전에(한번만) 조건 검사에 사용할 변수의 초기값 설정
- 조건 검사 (check control expression)
- 반복할 명령문 실행 (action)
- 업데이트 (loop update)
	- 무한 루프(infinite loop)가 되지 않게 조건이 거짓(false)이 되게 한다.
- 반복을 이용한 선택정렬
```python
def SelectionSort(A):
	n = len(A)
	for i in range(0, n-1):
		minI = i
		for j in range(i+1, n):
			if A[j] < A[minI]:
				minI = j
		A[minI], A[i] = A[i], A[minI]
```

#### 재귀적 알고리즘
- 재귀적 정의는 두 부분으로 나뉜다.
- 하나 또는 그 이상의 기본 경우(basis case or rule)
	- 집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드(seed)역할
- 하나 또는 그 이상의 유도된 경우(inductive case or rule)
	- 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법

- 재귀 함수(recursive function)
	- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수.
	- 일반적으로 재귀적 정의를 이용해서 재귀 함수를 구현한다.
	- 따라서, 기본 부분(basis part)와 유도 부분(inductive part)로 구성된다.
	- 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉽다.
	- 함수 호출 프로그램은 메모리 구조에서 스택을 사용한다.
		- 재귀호출은 == 반복적인 스택의 사용, 메모리 및 속도에서 성능 저하가 발생
```python
fact(n)
	if n <= 1               # Basis part
		return 1
	else:                   # Inductive part
		return n * fact(n-1)
```

## 완전 검색 기법
- 완전 검색을 통한 Baby-gin 접근
- 고려할 수 있는 모든 경우의 수 생성하기
	- 6개의 숫자로 만들 수 있는 모든 숫자 나열 (중복 포함 )
	- ex> 입력으로 {2, 3, 5, 7, 7, 7}을 받았을 경우, 다음과 같은 순열 생성
```
2 3 5 7 7 7
2 3 7 5 7 7
2 3 7 7 5 7
    ...
7 7 7 5 3 2
```
- 해답 테스트하기
	- 앞의 3자리와 뒤의 3자리를 잘라, run 와 triplet 여부를 테스트하고 최종적으로 baby-gin 을 판단
	- ex> 2, 3, 5, 7, 7, 7     ------> baby-gin 아님
	-        -해당x- - triplet-
##### 완전 검색
- 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것.
- 또한, 이들은 전형적으로 순열(permutation), 조합(combination), 그리고 부분 집합(subset))과 같은 조합적 문제들 (Combinatorial Problems) 과 연관
- 완전 검색은 조합적 문제에 대한 brute- force 방법

## 순열
- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열은 <sub>n</sub>P<sub>r</sub> 같이 표현
- <sub>n</sub>P<sub>r</sub>  = n * (n-1) * (n-2) * ... * (n-r+1)
- <sub>n</sub>P<sub>n</sub> = n!
- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있다. (TSP(Traveling Salesman Problem 처럼)) (도시를 도는 순서 등)
- N개의 요소들에 대해 n! 개의 순열들이 존재한다.
	- 12! = 479,001,600
	- if n > 12:  --> 시간복잡도는 폭발적 증가
- 단순하게 순열을 생성하는 방법
	- {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
		- 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop을 이용해 아래와 같이 구현이 가능하다.
``` python
for i1 in range(1, 4):
	for i2 in range(1, 4):
		if i2 != i1
			for i3 in range(1, 4):
				if i3 != i1 and i3 != i2
					print(i1, i2, i3)
```

- 재귀 호출을 통한 순열 생성
	- 자리를 바꾸는 방식
``` python
# p[] : 데이터가 저장된 배열
# k : 값을 결정할 개수,
# i : 값을 결정할 자리
def perm(i, k)
	if i == k
		print(*p) # 원하는 작업 수행
	else:
		for j in range(i, k):  # 자신부터 오른쪽 원소들과 교환
			p[i], p[j] = p[j], p[i]
			perm(i+1, k)
			p[i], p[j] = p[j], p[i]


p = [1, 2, 3]
perm(0, 3)
```

- 앞에서 사용하지 않은 숫자를 사용하는 방식 ---> 사전 순서대로 생성
```python
def perm(i, k):
	if i==k:
		print(*p)
	else:
		for j in range(k):     # 사용하지 않은 숫자를
			if used[j] == 0:   # used 에서 순서대로 검색
				p[i] = A[j]
				used[j] = 1    # j번 자리 숫자 사용으로 표시
				perm(i+1, k)
				used[j] = 0    # j번 자리 숫자를 다른 자리에서 쓸 수 있게

A = [1, 4, 5]
p = [0] * 3
used = [0] * 3
perm(0, 3)

```

---
## 부분 집합
- 집합에 포함된 원소들을 선택하는 것
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것이다.
	- EX > 배낭 짐싸기(knapsack)
- N 개의 원소를 포함한 집합
	- 자기 자신과 공집합 포함한 모든 부분집합(power set)의 개수는 2<sup>n</sup> 개
	- 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가
#### 부분집합 생성 방법
- 바이너리 카운팅을 통한 사전적 순서(Lexicographic Order)
	- 부분집합을 생성하기 위한 가장 자연스러운 방법
	- 바이너리 카운팅(Binary Counting)은 사전적으로 생성하기 위한 가장 간단한 방법
	- 원소 수에 해당하는 N개의 비트열을 이용한다.
	- n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미한다.
	- 예시
```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)

for i in range(0, (1<<n)):   # 1<<n : 부분집합의 개수
	for j in range(0, n):    # 원소의 수만큼 비트를 비교함
        if i & (1<<j):           # i의 j번째 비트가 1이면 j번째 원소 출력
        # ↑ i의 j번 비트가 1인지 검사하는 코드
            print('%d'%arr[j], end='')
    print()
```

---
## 조합
- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합(combination)이라고 부른다.
- 조합의 수식
	- <sub>n</sub>C<sub>r</sub> = n! / (n-r)!r!  ,  (n >= r)
	- <sub>n</sub>C<sub>r</sub> = <sub>n-1</sub>C<sub>r-1</sub> + <sub>n-1</sub>C<sub>r</sub>          ---> 재귀적 표현
	- <sub>n</sub>C<sub>0</sub> = 1
- 재귀 호출을 이용한 조합 생성 알고리즘
```python
an[] : n개의 원소를 갖고 있는 배열
tr[] : r개의 크기의 배열, 조합이 임시 저장될 배열

comb(n, r)
	if r==0
	print(arr())
	elif n < r:
	return
	else:
		tr[r-1] = an[n-1]
		comb(n-1, r-1)
		comb(n-1, r)
```

- (참고) N개의 원소 중 M개를 고르는 조합
	- i< j < k ... (len = M) 라고 하면,
```python
for i in range(0, N-M+1):      # N-M의 경계 까지니까 +1
	for j in range(i+1, N-M+2):
		for k in range(j+1, N-M+3):
			...
				f(a[i],a[j],a[k], ... )
```
- 재귀로 n개에서 r개를 고르는 조합
```
def nCr (n,r,s):    # n개에서 r개를 고르는 조합, s 선택할 수 있는 구간의 시작
	if r==0:
		point(*comb)
	else:
		for i in range(s, n-r+1):
			comb[r-1] = A[i]
			nCr(n, r-1, i+1)
```
```python
def nCr(n, r, s):  # n개에서 r개를 고르는 조합. s는 고를 수 있는 구간의 시작 인덱스
    if r==0:
        print(comb)
    else:
        for i in range(s, n-r+1):
            comb[r-1] = A[i]
            nCr(n, r-1, i+1)

n = 5
r = 3
comb = [0] * 3
A = [i for i in range(n)]
nCr(n, r, 0)
```

---
## 탐욕(Greedy) 알고리즘
- 탐욕 알고리즘은 최적해를 구하는데 사용되는 근시안적인 방법
- 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.
- 여러 경우 중 하나를 선택 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집해 최종 해답을 만들었을 때, **그것이 최적이라는 보장 X**
- 일단, 한번 선택된 것은 번복되지 않는 특성 때문에 대부분의 탐욕 알고리즘은 단순, 또한 제한적 문제들에 적용
- 최적화 문제(optimization)란 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제이다.

##### 동작 과정
1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합(Solution Set)에 추가한다.
2. 실행 가능성 검사 : 새로운 부분 해 집합이 실행 가능한지를 확인한다. 곧 문제의 제약 조건을 위반하는지 검사
3. 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작

#### 배낭 짐싸기(Knapsack)
- Knapsack 문제 유형
	- 0-1 Knapsack
		- 배낭에 물건을 통째로 담아야 하는 문제.
		- 물건을 쪼갤 수 없는 경우
	- Fractional Knapsack
		- 물건을 부분적으로 담는 것이 허용되는 문제.
		- 물건을 쪼갤 수 있는 경우

##### 0-1 Knapsack에 대한 완전 검색 방법
- 완전 검색으로 물건들의 집합 S에 대한 모든 부분집합을 구한다.
- 부분집합의 총 무게가 W를 초과하는 집합들은 버리고, 나머지 집합에서 총 값이 가장 큰 집합을 선택할 수 있다.
- 물건의 개수가 증가하면 시간 복잡도가 지수적으로 증가한다.
	- 크기 n인 부분합의 수 2<sup>n</sup> 
- 0-1 Knapsack은 Greedy 알고리즘이 X

##### Fractional Knapsack문제
예시
|--|무게|값|값/kg|
|--|--|--|--|
|물건1|5kg|50만원|10만원/kg|
|물건2|10kg|60만원|6만원/kg|
|물건3|20kg|140만원|7만원/kg|

- 물건의 일부를 잘라서 담을 수 있다.
- Greedy 한 방법
	- 물건1 + 물건3 + 물건2의 절반, 30kg 220만원

##### 활동 선택(Activity-selection problem) 문제
- 탐욕 기법을 적용한 알고리즘
```
A : 활동들의 집합, S: 선택된 활동들 집합
si: 시작시간, fi: 종료시간, 1<= i <= n

Sort A by finish time
S ← {A1}
j ← 1
for i in 2 → n
	if si >= fj
		S ← S U {Ai}
		j ← i
```
- 종료 시간이 빠른 순서로 활동들을 정렬한다.
- 첫 번째 활동(A1) 을 선택한다.
- 선택한 활동(A1) 의 종료 시간보다 빠른 시작 시간을 가지는 활동을 모두 제거한다.
- 남은 활동들에 대해 앞의 과정을 반복한다.
- 활동 선택 문제는 반복으로 푸는게 나음
