## 재귀
#### 반복 vs 재귀
-  반복 : 수행하는 작업이 완료될 때까지 계속 반복
	-  루프 (for, while 구조)
	
 - 재귀 : 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
	 - 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합한다.
	-  재귀 함수로 구현

#### 반복 구조
- 초기화 : 반복되는 명령문을 실행하기 전에(한번만) 조건 검사에 사용할 변수의 초기값 설정
- 조건 검사 (check control expression)
- 반복할 명령문 실행 (action)
- 업데이트 (loop update)
	- 무한 루프(infinite loop)가 되지 않게 조건이 거짓(false)이 되게 한다.
- 반복을 이용한 선택정렬
```python
def SelectionSort(A):
	n = len(A)
	for i in range(0, n-1):
		minI = i
		for j in range(i+1, n):
			if A[j] < A[minI]:
				minI = j
		A[minI], A[i] = A[i], A[minI]
```

#### 재귀적 알고리즘
- 재귀적 정의는 두 부분으로 나뉜다.
- 하나 또는 그 이상의 기본 경우(basis case or rule)
	- 집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드(seed)역할
- 하나 또는 그 이상의 유도된 경우(inductive case or rule)
	- 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법

- 재귀 함수(recursive function)
	- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수.
	- 일반적으로 재귀적 정의를 이용해서 재귀 함수를 구현한다.
	- 따라서, 기본 부분(basis part)와 유도 부분(inductive part)로 구성된다.
	- 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉽다.
	- 함수 호출 프로그램은 메모리 구조에서 스택을 사용한다.
		- 재귀호출은 == 반복적인 스택의 사용, 메모리 및 속도에서 성능 저하가 발생
```python
fact(n)
	if n <= 1               # Basis part
		return 1
	else:                   # Inductive part
		return n * fact(n-1)
```

## 완전 검색 기법
- 완전 검색을 통한 Baby-gin 접근
- 고려할 수 있는 모든 경우의 수 생성하기
	- 6개의 숫자로 만들 수 있는 모든 숫자 나열 (중복 포함 )
	- ex> 입력으로 {2, 3, 5, 7, 7, 7}을 받았을 경우, 다음과 같은 순열 생성
```
2 3 5 7 7 7
2 3 7 5 7 7
2 3 7 7 5 7
    ...
7 7 7 5 3 2
```
- 해답 테스트하기
	- 앞의 3자리와 뒤의 3자리를 잘라, run 와 triplet 여부를 테스트하고 최종적으로 baby-gin 을 판단
	- ex> 2, 3, 5, 7, 7, 7     ------> baby-gin 아님
	-        -해당x- - triplet-
##### 완전 검색
- 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것.
- 또한, 이들은 전형적으로 순열(permutation), 조합(combination), 그리고 부분 집합(subset))과 같은 조합적 문제들 (Combinatorial Problems) 과 연관
- 완전 검색은 조합적 문제에 대한 brute- force 방법

## 순열
- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열은 <sub>n</sub>P<sub>r</sub> 같이 표현
- <sub>n</sub>P<sub>r</sub>  = n * (n-1) * (n-2) * ... * (n-r+1)
- <sub>n</sub>P<sub>n</sub> = n!
- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있다. (TSP(Traveling Salesman Problem 처럼)) (도시를 도는 순서 등)
- N개의 요소들에 대해 n! 개의 순열들이 존재한다.
	- 12! = 479,001,600
	- if n > 12:  --> 시간복잡도는 폭발적 증가
- 단순하게 순열을 생성하는 방법
	- {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
		- 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop을 이용해 아래와 같이 구현이 가능하다.
``` python
for i1 in range(1, 4):
	for i2 in range(1, 4):
		if i2 != i1
			for i3 in range(1, 4):
				if i3 != i1 and i3 != i2
					print(i1, i2, i3)
```

- 재귀 호출을 통한 순열 생성
	- 자리를 바꾸는 방식
``` python
# p[] : 데이터가 저장된 배열
# k : 값을 결정할 개수,
# i : 값을 결정할 자리
def perm(i, k)
	if i == k
		print(*p) # 원하는 작업 수행
	else:
		for j in range(i, k):  # 자신부터 오른쪽 원소들과 교환
			p[i], p[j] = p[j], p[i]
			perm(i+1, k)
			p[i], p[j] = p[j], p[i]


p = [1, 2, 3]
perm(0, 3)
```

- 앞에서 사용하지 않은 숫자를 사용하는 방식 ---> 사전 순서대로 생성
```python
def perm(i, k):
	if i==k:
		print(*p)
	else:
		for j in range(k):     # 사용하지 않은 숫자를
			if used[j] == 0:   # used 에서 순서대로 검색
				p[i] = A[j]
				used[j] = 1    # j번 자리 숫자 사용으로 표시
				perm(i+1, k)
				used[j] = 0    # j번 자리 숫자를 다른 자리에서 쓸 수 있게

A = [1, 4, 5]
p = [0] * 3
used = [0] * 3
perm(0, 3)

```