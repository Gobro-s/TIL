## INDEX
1. 분할정복
2. 퀵 정렬
3. 이진 검색
4. 백트래킹
5. 트리

---

## 1. 분할정복
> 예시 문제. 가짜 동전 찾기
- 설계 전략
	- 분할 (Divide) : 해결할 문제를 여러 개의 작은 부분으로 나눈다.
	- 정복 (Conquer) : 나눈 작은 문제를 각각 해결한다.
	- 통합 (Combine) : (필요하다면) 해결된 해답을 모은다.
- 반복(Iterative) 알고리즘 : O<sub>n</sub>
```python
def Iterative_Power(x,n)
	result ← 1
	for i in range(1, n):
		result ← result * x
	return result
```

- 분할 정복 기반의 알고리즘 :  O(log<sub>2</sub>n)
	- C<sup>8</sup> = C x C x C x C x C x C x C x C
	- C<sup>8</sup> = C<sup>4</sup> x C<sup>4</sup> = (C<sup>4</sup>)<sup>2</sup> = ((C<sup>2</sup>)<sup>2</sup>)<sup>2</sup>
	- C<sup>n</sup> = C<sup>(n-1) / 2</sup> x C<sup>(n-1) / 2</sup> x C = (C<sup>(n-1) / 2</sup>)<sup>2</sup>  x  C
	- C<sup>n</sup>
		- n 은 짝수 일 때 
			- C<sup>n / 2</sup>  x  C<sup>n / 2</sup>
		- n 은 홀수 일 때
			- C<sup>(n-1) / 2</sup>  x  C<sup>(n-1) / 2</sup>  x  C

```python
Recursive_Power(x, n)
	if n == 1:
		return x
	elif n is even
		y ← Recursive_Power(x, n/2)
		return y * y
	else:
		y ← recursive_Power(x, (n-1)/2)
		return y * y * x
```

##### 병합정렬(Merge Sort) : 분할정복의 대표적 알고리즘
- 여러 개의 정렬된 자료를 집합으로 병합하여 한 개의 정렬된 집합으로 만드는 방식
- 분할 정복 알고리즘 활용
	- 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
	- top-down 방식
- 시간 복잡도
	- O(n log n)
- 과정 예시
	- 분할 단계 : 전체 자료 집합에 대해, 최소 크기(1개)의 부분집합이 될 때가지 분할 작업을 계속한다. 최소 크기가 되면 return 
	- 병합 단계 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합. 8개의 부분집합이 1개로 병합될 때까지 반복함
- 분할 과정 알고리즘
```python
merge_sort(LIST m)
	if length(m) == 1 : return m  # 한 칸 짜리면 정렬 완료된거니까 그냥 return

	else:
		list left, right          # 왼쪽, 오른쪽 두 개의 저장 공간을 만들어
		middle ← length(m) / 2
		for x in m before middle
			add x to left         # 왼쪽 절반 왼쪽 공간에 복사
		for x in m after or equal middle
			add x to right        # 오른쪽 절반 오른쪽 공간에 복사

		left ← merge_sort(left)    # 왼족 절반 줄테니 정렬해서 되돌려 줘
		right ← merge_sort(right)  # 오른쪽  "    "      "        "
		
		return merge(left, right)
	
```

- 병합 과정 알고리즘
```python
merge(List left, List right)
	List result

	while length(left) > 0 or length(right) > 0  # 왼쪽이든 오른쪽이든 남아있으면
		if length(left) > 0 and length(right) > 0
			if first(left) <= first(right):
				append popfirst(left) to result
			else:
				append popfirst(right) to result
		elif length(left) > 0:
			append posfirst(left) to result
		elif length(right) > 0:
			append popfirst(right) to result
	return result
			
```

---
## 2. 퀵 정렬
- 주어진 배열을 두개로 분할하고, 각각을 정렬. but 병합 정렬과 다른 점.
	1. 병합 정렬은 그냥 두 부분으로 나누는 반면, 퀵 정렬은 분할할 때, 기준 아이템(pivot item) 중심으로, 이보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다.
	2. 각 부분 정렬이 끝난 후, 병합정렬은 "병합"이란 후처리 작업이 필요하나, 퀵 정렬은 필요로 하지 않는다.
알고리즘
```python
quickSort(A[], l, r)
	if l < r
		s ← partition(a, l, r)
		quickSort(A[], l, s - 1)
		quickSort(A[], s + 1, r)
```

###### 파티셔닝 방법 중
- Hoare-Partition 알고리즘
```python
partition(A[], l, r)
	p ← A[l]           # p : 피봇 값
	i ← l, j ← r
	while i <= j
		while i <= j and A[i] <= p:
			i += 1
		while i <= j and A[j] >= p:
			j -= 1
		if i < j:   # 교차 한 경우  ----> 큰애들, 작은애들 큰쪽 작은쪽 몰아놓은 것
		A[i], A[j] == A[j], A[i]

	swap(A[l], A[j])
	return j
```
- Lomuto-Partition 알고리즘
```python
partition(A[], p, r)
	x ← A[r]
	i ← p - 1

	for j in p → r-1
		if A[j] <= x
			i += 1
			A[i], A[j] == A[j], A[i]

	A[i+1], A[r] == A[r], A[i+1]
	return i+1
```