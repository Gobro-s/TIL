## INDEX
1. 그래프 기본
2. DFS
3. BFS
4. 서로소 집합들
5. 최소 비용 신장 트리(MST)
6. 최단 경로

---
## 1. 그래프 기본
- 그래프는 정점들의 집합과 이들을 연결하는 간선들의 집합으로 구성된 자료
- 그래프는 선형 자료구조나 트리 자료구조로 표현하기 어려운 **N:N 관계**를 가지는 원소들을 표현하기에 용이하다.

### 그래프 유형
- 무향 그래프(Undirectied Graph)
	- 방향이 없는 그래프
- 유향 그래프(Directed Graph)
	- 방향 표시가 있는 그래프
- 가중치 그래프(Weighted Graph)
	- 비용 등 가중치가 간선에 적혀있다
- 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph)
	- 사이클 : 시작한 정점에서 끝나는 경로를 사이클이라고 한다
		- ex> 1-3-5-1
- 완전 그래프
	- 정점들에 대해 가능한 모든 간선들을 가진 그래프
- 부분 그래프
	- 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프

### 인접 정점
- 인접(Adjacency)
	- 두 개의 정점에 간선이 존재(연결됨)하면 서로 인접해 있다고 한다.
	- 완전 그래프에 속한 임의의 두 정점들은 모두 인접해 있다.

### 그래프 경로
- 경로란 간선들을 순서대로 나열한 것
	- 간선들 : (0, 2), (2, 4), (4, 6)
	- 정점들 : 0-2-4-6
- 경로 중 한 정점을 최대한 한번만 지나는 경로를 **단순경로**라 한다.
	- 0-2-4-6, 0-1-6
- 시작한 정점에서 끝나는 경로를 **사이클(Cycle)** 이라고 한다.
	- 1-3-5-1

### 그래프 표현
- 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정
- 인접 행렬(Adjacent matrix)
	- |V| x |V| 크기의 2차원 배열을 이용해서 간선 정보를 저장
	- 배열의 배열(포인터 배열)
- 인접 리스트(Adjacent List)
	- 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장
- 간선의 배열
	- 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장
#### 인접 행렬
- 두 정점을 연결하는 간선의 유무를 행렬로 표현
	- |V| x |V| 정방 행렬
	- 행 번호와 열 번호는 그래프의 정점에 대응
	- 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현
	- 무향 그래프
		- i 번째 행의 합 = i 번째 열의 합 = Vi 의 차수
	- 유향 그래프
		- 행 i의 합 = Vi의 진출 차수
		- 열 i의 합 = Vi의 진입 차수
	- ![[유향_무향인풋차이.png]]
---
중간생략

---
## 0404
## 4. 서로소 집합들

- 집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분, 이를 대표자(representative)라고 한다

#### 상호배타 집합 예
- Make-Set(x) : 원소 x로만 이루어진 집합을 만든다.
- Make-Set(y)
- Make-Set(a)
- Make-Set(b)
- Union(x, y)
- Union(a, b)
- Find-Set(y) : 원소 y를 갖고 있는 집합을 알아낸다.
	- return x (representative)
- Find-Set(b)
	- return a (representative)
- Union(x, a) : 원소 x를 가진 집합과 원소 y를 가진 집합의 합집합

#### 상호 배타 집합 표현 - 트리
- 하나의 집합(a disjoint set)을 하나의 트리로 표현한다.
- 자식 노드가 부모 노드를 가리키며 루트  노드가 대표자가 된다.
- ex![[상호배타집합표현트리.png]]
##### 연산 예
- Make-Set(a) ~ Make-Set(f)
![[연산예시.png]]
idx  0  1  2  3  4  5  6
rep X  1  2  3  4  5  6
- Union(c, d), Union(e,f)
- ![[연산예시2.png]]
- idx  0  1  2  3  4  5  6
- rep  X 1  2  3  3  5  5

- Union(d,f)
- ![[Uniondf.png]]
- Find-Set(d)
	- return c
- Find-Set(e)
	- return c

- 상호배타 집합을 표현한 트리의 배열을 이용한 저장된 모습
- ![[Uniondf.png]]
|첨자|0|1|2|3|4|5|
|--|--|--|--|--|--|--|
|정점|a|b|c|d|e|f|
|부모|0|1|2|2|2|4|

```python
# Make-Set(x) : 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산
rep = [i for i in range(6)]  # 각각 대표원소 하나씩 갖고 있는 집합 생성

# Find-Set(x) : x를 포함하는 집합을 찾는 연산
def find_set(x):  # x가 속한 집합의 대표 return
    while x != rep[x]:  # rep[x] == x면 대표.
        x = rep[x]
    return x

# Union(x,y) : x와 y를 포함하는 두 집합을 통합하는 연산
def union(x, y):  # y의 대표원소가 x의 대표원소를 가리키도록 해줘
    rep[find_set(y)] = find_set(x)

    # rep[y] = find_set(x)    #<<====이거 아님====###
```

---
## 5. 최소 비용 신장 트리 (MST)

### 최소 신장 트리(MST)
- 그래프에서 최소 비용 문제
	1. 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
	2. 두 정점 사이의 최소 비용의 경로 찾기
- 신장 트리
	- n 개의 정점으로 이루어진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
- 최소 신장 트리(Minimum Spanning Tree)
	- 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리

![[MST1.png]]

![[MST2.png]]

### KRUSKAL알고리즘
- 간선을 하나씩 선택해서 MST를 찾는 알고리즘
	1. 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
	2. 가중치가 낮은 간선부터 선택하면서 트리를 증가시킴
		1. 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택(사이클이 생기면 안됨)
		2. 즉, dfs, bfs 활용 . 방문한 곳을 또 방문하면 안된다.
	3. n-1개의 간선이 선택될 때 까지 2.를 반복한다
![[Kruskal.jpg]]
(출처 : http://cbb1225.tistory.com/entry/%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%ACMinimum-Cost-Spanning-Trees)

###### Kruskal 과정
// 중간중간 사이클이 생기는지를 검사

(a) : 상태는 간선들의 가중치를 나타낸 그래프
(c) : (b)상태에서 가장 가중치가 낮은 값은 10이므로 (0, 5)를 선택
(d) : 그 다음으로 가중치가 낮은 값인 12, (2, 3)을 선택
(e) : 그 다음으로 가중치가 낮은 값인 14, (1, 6)을 선택
(f)  : 가중치 16, (1, 2) 선택
(g) : 그 다음으로 가중치가 낮은 값이 18이지만, (3, 6)을 선택할 경우 사이클이 생기므로 간선을 버리고, 그 다음 가중치 22(3, 4)를 선택
(h) : 가중치 24, (4, 6)를 선택할 경우 사이클이 생기므로, 가중치 25를 선택, 간선의 총 갯수가 정점의 갯수보다 1개 작으므로 종료

- 알고리즘
```python
def MST-KRUSKAL(G, w):
	A <- 0              # 0 : 공집합
	for vertex v in G.V        # G.V: 그래프의 정점 집합
		Make_Set(v)            # G.E: 그래프의 간선 집합

	G.E 에 포함된 간선들을 가중치 w에 의해 정렬

	for 가중치가 낮은 간선 (u, v) ∈ G.E 선택 (n-1개)
		if Find_Set(u) != Fine_Set(v)
			A <- A ∪ {(u, v)}
			Union(u,v);
	return A
```

---

## 6. 최단경로

### 최단 경로
- 최단 경로 정의
	- 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로
- 하나의 시작 정점에서 끝 정점까지의 최단 경로
	- 다익스트라(dijkstra) 알고리즘
		- 음의 가중치를 허용하지 않음
	- 벨만-포드(Bellman-Ford) 알고리즘
		- 음의 가중치 허용
- 모든 정점들에 대한 최단 경로
	- 플로이드-워샬(Floyd-Warshall) 알고리즘

### Dijkstra 알고리즘
- 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식
- 시작정점(s)에서 끝정점(t) 까지의 최단 경로에 정점 x가 존재한다.
- 이때, 최단경로는 s에서 x까지의 최단 경로와 x에서 t까지의 최단경로 구성된다.
- 탐욕 기법을 사용한 알고리즘으로 MST의 프림 알고리즘과 유사하다.