## INDEX
1. 문자의 표현
2. 문자열
3. 패턴 매칭
4. 문자열 암호화
5. 문자열 압축

---
## 1. 문자의 표현

- 메모리는 숫자만을 저장할 수 있기 때문에 A라는 글자의 모양 그대로 비트맵으로 저장하지 않는 한(메모리 낭비), 각 문자에 대해서 대응되는 숫자를 정해 놓고 이것을 메모리에 저장하는 방법이 사용된다.
- 예를 들어 영어는 대소문자 합쳐서 52 이므로 6(64가지)비트면 모두 표현이 가능하다. 이를 코드체계라고 한다.
	-  000000 -> 'a' , 000001 -> 'b'
- 혼동을 피하기 위해 1967 미국에서 ASCII라는 문자 인코딩 표준이 제정.
- ASCII는 7bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어져 있다.

- 확장 아스키는 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가할 수 있게 해주는 부호이다.
	- 표준 아스키는 7bit를 사용하여 문자를 표현하는 데 비해 확장 아스키는 1B 내의 8bit를 모두 사용함으로써 추가적인 문자를 표현할 수 있다.
	- 컴퓨터 생산자와 소프트웨어 개발자가 여러 가지 다양한 문자에 할당할 수 있도록 하고있다. 이렇게 할당된 확장 부호는 표준 아스키와 같이 서로 다른 프로그램이나 컴퓨터 사이에 교환되지 못한다.
	- 그러므로 표준 아스키는 마이크로컴퓨터 하드웨어 및 소프트웨어 사이에서 세계적으로 통용되는 데 비해, 확장 아스키는 프로그램이나 컴퓨터 또는 프린터가 그것을 해독할 수 있도록 설계되어 있어야만 올바로 해독될 수 있다.
- 오늘날 대부분의 컴퓨터는 문자를 읽고 쓰는데 ASCII 형식 사용
- 국가간 정보를 주고받을 때 자국의 코드체계를 타 국가가 가지고 있지 않으면 정보를 잘못 해석할 수밖에 없었고, 그래서 다국어 처리를 위한 표준 유니코드를 마련

##### 유니코드
- 유니코드도 다시 Character Set으로 분류된다.
	- USC-2(Universal Character Set 2)
	- USC-4(Universal Character Set 4)
	- 유니코드를 저장하는 변수의 크기를 정의
	- 그러나, 바이트 순서에 대해서 표준화하지 못했음
	- 다시 말해 파일을 인식 시 이 파일이 USC-2인지, USC-4인지 인식하고 각 경우를 구분해서 모두 다르게 구현해야 하는 문제 발생
	- 그래서 유니 코드의 적당한 외부 인코딩이 필요하게 됐다.

##### 유니코드 인코딩(UTF: Unicode Transformation Format)
- UTF-8(in wab)
	- MIN : 8bit, MAX : 32bit(1Byte * 4)
- UTF-16 (in windows, java)
	- MIN : 16bit, MAX : 32bit(2Byte * 2)
- UTF-32 (in unix)
	- MIN : 32bit, MAX : 32bit(4Byte * 1)

- python 인코딩
	- 2.x 버전 - ASCII -> #\-\*\- coding: utf\-8 \-\*\- (첫줄에 명시)
	- 3.x 버전 - 유니코드 UTF-8 -> 생략 가능
	- 다른 인코딩 방식으로 처리 시 첫 줄에 작성하는 위 항목에 원하는 인코딩 방식 지정

---

## 2. 문자열

### 문자열의 분류

문자열(string) →fixed length
	         └-----→variable length --→ length controlled (java 언어에서의 문자열)
	                                    └--------→delimited (c언어에서의 문자열)

- java에서 String 클래스에 대한 메모리 배치
	- java.lang.String 클래스에는 기본적인 객체 메타 데이터 외에도 네가지 필드들이 포함되어 있는데, hash값(hash), 문자열의 길이(count), 문자열 데이터의 시작점(offset), 그리고 실제 문자열 배열에 대한 참조(value)이다.

- c언어에서 문자열 처리
	- 문자열은 문자들의 배열 형태로 구현된 응용 자료형
	- 문자배열에 문자열을 저장할때는 항상 마지막에 끝을 표시하는 널 문자(''\\0')를 넣어줘야 한다.
```c
char ary[] = {'a', 'b', 'c', '\0'}; //
또는
char ary[] = "abc";
```
- 문자열에서 필요한 연산을 함수 형태로 제공한다.
```c
strlen(), strcpy(), strcmp(), ...
```

- Java(객체지향 언어)에서의 문자열 처리
	- 문자열 데이터를 저장, 정리해주는 클래스를 제공한다.
	- String클래스를 사용한다.
```java
String str="abc"; //
또는
String str = new String("abc")
```
		- 문자열 처리에 필요한 연산을 연산자, 메소드 형태로 제공한다.
		- +, length(), replace(), split(), substring(),...
		- 보다 풍부한 연산을 제공한다.

- Python에서의 문자열 처리
	- char 타입 없음
	- 텍스트 데이터의 취급방법이 통일되어 있음
	- 문자열 기호
		- ', ", ''', """
		- + 연결(Concatention)
			- 문자열 + 문자열 : 이어 붙여주는 역할
		- * 반복
			- 문자열 * 수: 수만큼 문자열이 반복
	- 문자열은 시퀀스 자료형으로 분류되고, 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산들을 사용할 수 있음
	- 문자열 클래스에서 제공되는 메소드
	- 
```python
replace(), split(), isalpha(), find()
```
		- 문자열은 튜플과 같이 요소값을 변경할 수 없음(immutable)

- C와 Java, Python의 String 처리의 기본적인 차이점
	- c는 아스키 코드로 저장한다.
	- java는 유니코드(UTF16, 2byte)로 저장한다.
	- 파이썬은 유니코드(UTF8)로 저장

#### 문자열 뒤집기
- 자기 문자열에서 뒤집는 방법이 있고, 새로운 빈 문자열을 만들어 소스의 뒤에서부터 읽어서 타겟에 쓰는 방법이 있겠다.
- 자기 문자열을 이용할 경우는 swap을 위한 임시 변수가 필요하며 반복 수행을 문자열 길이의 반만을 수행해야 한다.

- #### python에서 문자열 뒤집기
- Ex) s = 'Reverse this strings'     # 'sgnirts siht esreveR'
	- s = s[::1]
	- s = 'abcd'
	- s = list(s)
	- s.reverse()
	- s = ".join(s)

- {참고} s1과 나머지 문자열을 \==, is 로 비교한 결과
	```python
	s1 = 'abc' 
	s2 = 'abc'
	s3 = 'def'
	s4 = s1
	s5 = s1[:2] + 'c'

	print(s1 == s2)      #True
	print(s1 is s2)      #True
	print(s1 == s5)      #True
	print(s1 is s5)      #False
	print(s5)            #abc
	# ==은 내용물 비교, is는 같은 애를 가리키는지 비교
```

- 다음 C코드를 참고해 문자열 비교 함수를 만들어봐.
	- 문자열이 같으면 0 리턴
	- str1이 str2보다 사전 순서상 앞서면 음수 혹은 -1 리턴
	- str1이 str2보다 사전 순서상 나중이면 양수 혹은 1 리턴
```c
int my_strcmp(const char *str1, const char *str2)
{
	int i = 0;
	while(str1[i] != '\0')
	{
		if(str1[i] != str2[i]) break;
		i++;
	}
	return (str1[i] - str2[i]);
}
```


### 문자열 숫자를 정수로 변환하기

- c 언어에서는 atoi()함수를 제공한다. 역함수로는 itoa()가 있다.
- java에서는 숫자 클래스의 parse 메소드를 제공한다.
	- 예 : Integer.parselnt(String)
	- 역함수로는 toString() 메소드를 제공한다.
- 파이썬에서는 숫자와 문자 변환 함수를 제공한다.
	- ex) int("123"), float("3.14"), str(123), repr(123)
- int()와 같은 atoi()함수 만들기
```python
s = '123'
a = atoi(s)
print(a+1)

def atoi(s):
	i = 0
	for x in s:
		i = i * 10 + ord(x) - ord('0')
	return i 
```

---

## 3. 패턴 매칭

#### 패턴 매칭에 사용되는 알고리즘들
- 고지식한 패턴 검색 알고리즘
- 카프-라빈 알고리즘
- KMP 알고리즘
- 보이어-무어 알고리즘

##### 고지식한 알고리즘(Brute Force)
- 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작
```python
t = [T, T, T, T, A, A, C, C, A, ...]
p = [T, T, A, T, T, T, C, T, A, ...]

while i<N and j<M: # t를 벗어나지 않는 범위여야 한다.
	if t[i] == p[j]: #를 비교
		i+=1
		j+=1  # 하나씩 증가 시키고 다음 인덱스 순서대로 비교
		
	else:
		i = i-j+1
		j = 0                    #이런 형식의 알고리즘으로 진행
```

```python
p = "is" #찾을 패턴
t = "This is a book~!" # 전체 텍스트
M = len(p)  # 찾을 패턴의 길이
N = len(t)  # 전체 텍스트의 길이

def BruteForce(p, t):
	i = 0  # t의 인덱스
	j = 0  # p의 인덱스
	while j < M and i < N:
		if t[i] != p[j]:
			i = i -j
			j = -1
		i = i + 1
		j = j + 1
	if j == M : return i - M  # 검색 성공
	else : return -1  #  검색 실패
```

```python
p = 'ab'  # 찾을 패턴  
t = 'aaaabaaaabaaaab'  # 전체 텍스트  
M = len(p)  
N = len(t)  
  
def bf(p,t, N, M):  
    i = 0  # t에서의 비교 위치  
    j = 0  # p에서의 비교 위치  
    while i < N and i < M:  # 비교할 문장이 남아있고, 패턴을 찾기 전이면(둘 다 만족할 때)  
        if t[i] != p[j]:    # 서로 다른 글자를 만나면  
            i -= j          # 비교를 시작한 위치로  
            j = -1          # 패턴의 시작 전으로  
        i += 1  
        j += 1  
    if j == M:  # 패턴을 찾은 경우  
        return i - M  
    else:  
        return -1  
  
print(bf(p, t, N, M))
```

```python
p = 'aba'  
t = 'aabaabababa'  
  
M = len(p)  
N = len(t)  
  
def bf2(p,t, N, M):  
    cnt = 0  
    for i in range(N - M +1):  
        for j in range(M):  
            if t[i+j] != p[j]:  
                break  
        else:  
            cnt += 1  
    return cnt  
print(bf2(p, t, N, M))
```

- 고지식한 패턴 검색 알고리즘의 시간 복잡도
	- 최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이 됨
	- 길이가 10000인 문자열에서 길이 80인 패턴을 찾는다고 할 때, 최악의 경우 약 10,000\*80 = 800,000 번의 비교가 일어난다.
	- 비교 횟수를 줄일 수 있는 방법은?

##### KMP 알고리즘
- 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
- 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
	- next[M] : 불일치가 발생했을 경우 이동할 다음 우치
- 시간 복잡도 : O(M+N)
- 아이디어 설명
	- 텍스트에서 abcdabc까지는 매치되고, e에서 실패한 상황 패턴의 맨 앞의 abc와 실패 직전의 abc는 동일함을 이용할 수 있다.
	- 실패한 텍스트 문자와 P[4]를 비교한다.
	- 매칭이 실패했을 때 돌아갈 곳을 계산한다.
```

```

##### 보이어-무어 알고리즘
- 오른쪽에서 왼쪽으로 비교
- 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
- 보이어-무어 알고리즘은 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이만큼이 된다.
```python
T = [., ., ., ., ., ., ., ., b, w, a, t, e, r, ., ., ., ...]
			p = [w, a, t, e, r]  # 불일치 시 len(p)만큼 한꺼번에 점프
							   [w, a, t, e, r]   # 오른쪽 끝부터 비교
```
- 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재할 경우
```python
T = [., ., ., ., ., ., ., ., w, a, t, e, r, ., ., ., ., ...]
			   p = [w, a, t, e, r]
							[w, a, t, e, r] 
							# 패턴에 일치하는 문자를 찾아서 세칸을 점프
```


- ##### 문자열 매칭 알고리즘 비교
	- 찾고자 하는 문자열 패턴의 길이 m, 총 문자열 길이 n
		- 고지식한 패턴 검색 알고리즘  : 수행시간 O(mn)
		- 카프-라빈 알고리즘 : 수행시간 Θ(n)
		- KMP 알고리즘 : 수행시간 Θ(n)
		- 보이어-무어 알고리즘
			- 앞의 두 매칭 알고리즘들의 공통점 텍스트 문자열의 문자를 적어도 한번씩 훑는다는 것이다. 따라서 최선의 경우에도 Ω(n)
			- 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 된다.
			- 발상의 전환 : 패턴의 오른쪽부터 비교한다.
			- 최악의 경우 수행시간 : Θ(mn)
			- 입력에 따라 다르지만 일반적으로 Θ(n)보다 시간이 덜 든다.